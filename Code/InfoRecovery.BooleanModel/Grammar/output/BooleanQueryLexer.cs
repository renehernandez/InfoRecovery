//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g 2014-12-08 10:37:17

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class BooleanQueryLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int AND=4;
	public const int LPAR=5;
	public const int NOT=6;
	public const int OR=7;
	public const int RPAR=8;
	public const int TERM=9;
	public const int WS=10;

    // delegates
    // delegators

	public BooleanQueryLexer()
	{
		OnCreated();
	}

	public BooleanQueryLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public BooleanQueryLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 1);
		TraceIn("WS", 1);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:12:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
			DebugEnterAlt(1);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:12:9: ( ' ' | '\\t' | '\\r' | '\\n' )
			{
			DebugLocation(12, 9);
			if ((input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(12, 38);
			_channel=Hidden;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 1);
			LeaveRule("WS", 1);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_TERM();
	partial void LeaveRule_TERM();

	// $ANTLR start "TERM"
	[GrammarRule("TERM")]
	private void mTERM()
	{
		EnterRule_TERM();
		EnterRule("TERM", 2);
		TraceIn("TERM", 2);
		try
		{
			int _type = TERM;
			int _channel = DefaultTokenChannel;
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:13:6: ( (~ ( '&' | '|' | '!' | '(' | ')' ) )+ )
			DebugEnterAlt(1);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:13:8: (~ ( '&' | '|' | '!' | '(' | ')' ) )+
			{
			DebugLocation(13, 8);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:13:8: (~ ( '&' | '|' | '!' | '(' | ')' ) )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>='\u0000' && LA1_0<=' ')||(LA1_0>='\"' && LA1_0<='%')||LA1_0=='\''||(LA1_0>='*' && LA1_0<='{')||(LA1_0>='}' && LA1_0<='\uFFFF')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:
					{
					DebugLocation(13, 8);
					input.Consume();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TERM", 2);
			LeaveRule("TERM", 2);
			LeaveRule_TERM();
		}
	}
	// $ANTLR end "TERM"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 3);
		TraceIn("AND", 3);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:14:5: ( '&' )
			DebugEnterAlt(1);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:14:7: '&'
			{
			DebugLocation(14, 7);
			Match('&'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AND", 3);
			LeaveRule("AND", 3);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 4);
		TraceIn("OR", 4);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:15:4: ( '|' )
			DebugEnterAlt(1);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:15:6: '|'
			{
			DebugLocation(15, 6);
			Match('|'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 4);
			LeaveRule("OR", 4);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 5);
		TraceIn("NOT", 5);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:16:5: ( '!' )
			DebugEnterAlt(1);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:16:7: '!'
			{
			DebugLocation(16, 7);
			Match('!'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT", 5);
			LeaveRule("NOT", 5);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_LPAR();
	partial void LeaveRule_LPAR();

	// $ANTLR start "LPAR"
	[GrammarRule("LPAR")]
	private void mLPAR()
	{
		EnterRule_LPAR();
		EnterRule("LPAR", 6);
		TraceIn("LPAR", 6);
		try
		{
			int _type = LPAR;
			int _channel = DefaultTokenChannel;
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:17:6: ( '(' )
			DebugEnterAlt(1);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:17:8: '('
			{
			DebugLocation(17, 8);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAR", 6);
			LeaveRule("LPAR", 6);
			LeaveRule_LPAR();
		}
	}
	// $ANTLR end "LPAR"

	partial void EnterRule_RPAR();
	partial void LeaveRule_RPAR();

	// $ANTLR start "RPAR"
	[GrammarRule("RPAR")]
	private void mRPAR()
	{
		EnterRule_RPAR();
		EnterRule("RPAR", 7);
		TraceIn("RPAR", 7);
		try
		{
			int _type = RPAR;
			int _channel = DefaultTokenChannel;
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:18:6: ( ')' )
			DebugEnterAlt(1);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:18:8: ')'
			{
			DebugLocation(18, 8);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAR", 7);
			LeaveRule("RPAR", 7);
			LeaveRule_RPAR();
		}
	}
	// $ANTLR end "RPAR"

	public override void mTokens()
	{
		// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:1:8: ( WS | TERM | AND | OR | NOT | LPAR | RPAR )
		int alt2=7;
		try { DebugEnterDecision(2, false);
		int LA2_0 = input.LA(1);

		if (((LA2_0>='\t' && LA2_0<='\n')||LA2_0=='\r'||LA2_0==' '))
		{
			int LA2_1 = input.LA(2);

			if (((LA2_1>='\u0000' && LA2_1<=' ')||(LA2_1>='\"' && LA2_1<='%')||LA2_1=='\''||(LA2_1>='*' && LA2_1<='{')||(LA2_1>='}' && LA2_1<='\uFFFF')))
			{
				alt2 = 2;
			}
			else
			{
				alt2 = 1;
			}
		}
		else if (((LA2_0>='\u0000' && LA2_0<='\b')||(LA2_0>='\u000B' && LA2_0<='\f')||(LA2_0>='\u000E' && LA2_0<='\u001F')||(LA2_0>='\"' && LA2_0<='%')||LA2_0=='\''||(LA2_0>='*' && LA2_0<='{')||(LA2_0>='}' && LA2_0<='\uFFFF')))
		{
			alt2 = 2;
		}
		else if ((LA2_0=='&'))
		{
			alt2 = 3;
		}
		else if ((LA2_0=='|'))
		{
			alt2 = 4;
		}
		else if ((LA2_0=='!'))
		{
			alt2 = 5;
		}
		else if ((LA2_0=='('))
		{
			alt2 = 6;
		}
		else if ((LA2_0==')'))
		{
			alt2 = 7;
		}
		else
		{
			NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
			DebugRecognitionException(nvae);
			throw nvae;
		}
		} finally { DebugExitDecision(2); }
		switch (alt2)
		{
		case 1:
			DebugEnterAlt(1);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:1:10: WS
			{
			DebugLocation(1, 10);
			mWS(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:1:13: TERM
			{
			DebugLocation(1, 13);
			mTERM(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:1:18: AND
			{
			DebugLocation(1, 18);
			mAND(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:1:22: OR
			{
			DebugLocation(1, 22);
			mOR(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:1:25: NOT
			{
			DebugLocation(1, 25);
			mNOT(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:1:29: LPAR
			{
			DebugLocation(1, 29);
			mLPAR(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// D:\\Eduar\\uh\\5to\\si\\InfoRecovery\\Code\\InfoRecovery.BooleanModel\\Grammar\\BooleanQuery.g:1:34: RPAR
			{
			DebugLocation(1, 34);
			mRPAR(); 

			}
			break;

		}

	}


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

 
	#endregion

}
